

node 中v8的内存限制：64位系统下约为1.4 GB，32位系统下约为0.7 GB。

#### V8的对象分配
> 所有的JavaScript对象都是通过堆进行分配的。
```javascript
process.memoryUsage()
{ 
  rss: 24498176, //resident set size进程的常驻内存
  heapTotal: 9682944, //v8堆内存目前总容量
  heapUsed: 5583760,  //v8堆内存目前已使用
  external: 8739 
}
```
进程的内存总共有几部分，一部分是rss，其余部分在交换区(swap)或者内存系统(filesystem)中。

以1.5GB的垃圾回收堆内存为例，做一次小的垃圾回收大约需要50ms，一次非增量式的回收大约要1s。这显然令人无法接受。因此在浏览器端，限制V8使用的内存大小是一个可以接受的选择。但是在node端，这种方法肯定是行不通的。那node采用的是什么方法获取性能和垃圾回收的高效处理呢？


#### Node的垃圾回收机制
实际的应用中，对象的生存周期长短不一，不同的算法只能对特定场景才能起到最好的效果。

##### node采用的垃圾回收算法
- V8的内存分代
在V8中，内存分为新生代和老生代。新生代可以理解为刚创建的对象，老生代是从新生代 “历劫” 过来的，存在时间已经比较长了。64位系统新生代内存大概可分配两个reserved_semispace_size 2*16MB，老生代大概1400MB，32位系统减半。

- Scavenge算法（新生代采用）
主要使用cheney算法，将堆内存一分为二，采用复制的方式实现。在两个semispace空间中，只有一个处于使用状态（From空间）,另一个处于闲置状态（To空间）。进行一次新生代垃圾回收时，From空间中的存活对象会复制到To空间，然后From空间和To空间完成角色互换。

![V8的堆内存示意图](/img/深入理解node/V8堆内存示意图.png)

- 新生代内存对象“晋升”到老生代内存
在一定条件下，需要将存活周期长的对象移动到老生代中。
两个条件满足其一即可： 
    - 一个是对象是否经历过Scavenge回收
    - 一个是To空间的内存占用比超过限制（25%）




- Mark-Sweep和Mark-Compact（老生代采用）
    - Mark-Sweep标记清除
    分为标记和清除两个阶段。