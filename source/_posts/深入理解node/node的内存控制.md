---
title: Node.js的内存控制
toc: true
comment: on
donate: true
tags:
 - node.js
 - 内存
 - 垃圾回收
categories:
 - [博客]
---

`node` 中`v8`的内存限制：64位系统下约为`1.4GB`，32位系统下约为`0.7GB`。

### V8的对象分配
> 所有的`JavaScript`对象都是通过堆进行分配的。
```javascript
process.memoryUsage()
{ 
  rss: 24498176, //resident set size进程的常驻内存
  heapTotal: 9682944, //v8堆内存目前总容量
  heapUsed: 5583760,  //v8堆内存目前已使用
  external: 8739 
}
```
`node`进程的内存总共有几部分，一部分是`rss`，其余部分在交换区`(swap)`或者内存系统`(filesystem)`中。

以`1.5GB`的垃圾回收堆内存为例，做一次小的垃圾回收大约需要`50ms`，一次非增量式的回收大约要`1s`。这显然令人无法接受。因此在浏览器端，限制V8使用的内存大小是一个可以接受的选择。但是在`node`端，这种方法肯定是行不通的。那node采用的是什么方法获取性能和垃圾回收的高效处理呢？


### Node的垃圾回收机制
实际的应用中，对象的生存周期长短不一，不同的算法只能对特定场景才能起到最好的效果。

node采用的垃圾回收算法（V8的内存分代）：在`V8`中，内存分为新生代和老生代。新生代可以理解为刚创建的对象，老生代是从新生代 “历劫” 过来的，存在时间已经比较长了。64位系统新生代内存大概可分配两个`reserved_semispace_size` 2*16MB，老生代大概`1400MB`，32位系统减半。

- 2.1 新生代采用的算法（`Scavenge`算法）
主要使用`cheney`算法，将堆内存一分为二，采用复制的方式实现。在两个semispace空间中，只有一个处于使用状态（`From`空间）,另一个处于闲置状态（`To`空间）。进行一次新生代垃圾回收时，From空间中的存活对象会复制到`To`空间，然后`From`空间和To空间完成角色互换。

  - 新生代内存对象“晋升”到老生代内存：在一定条件下，需要将存活周期长的对象移动到老生代中。两个条件满足其一即可： 
  （i） 一个是对象是否经历过`Scavenge`回收
  （ii）一个是To空间的内存占用比超过限制（`25%`）

![V8的堆内存示意图](/img/深入理解node/V8堆内存示意图.png)

  




- 2.2 老生代采用的算法
    - `Mark-Sweep`标记清除
    分为标记和清除两个阶段。在标记阶段遍历所堆中的所有对象，并标记活着的对象；在清除阶段，只清除没有标记的对象。该方法不需要经历对象的复制，清除速度快，但是会产生不连续的内存空间，不利于接下来大内存的分配。

    - `Mark-Compact`标记清理
    在`Mark-Sweep`的基础上提出来，解决其产生不连续内存空间的问题。差别在于标记死亡的对象，将活着的对象往一端移动，移动完成后，直接清理另一端的内存。缺点是需要复制移动对象，速度较慢。

    - `Incremental Marking`增量标记
    为了保持内存空间对于应用逻辑和垃圾回收机制的一致性，进行垃圾回收时，一般需要将应用程序停下来。这种停顿对于新生代的垃圾回收来说，影响不大，毕竟新生代内存小，回收花费的时间少。但是对于老生代内存垃圾回收来说，回收停顿带来的影响就很大了。为了降低这种影响，提出一种增量标记的方法。在标记阶段，将原本需要一次性标记的过程分为多次，进行递进标记，`JavaScript`应用于垃圾回收交替执行，直到标记完，再进行整理。