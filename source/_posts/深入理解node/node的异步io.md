
##Node.js异步非阻塞io

- 异步基于多线程的。
- 阻塞简单来说是函数执行先不返回真正结果，先返回特定值；

- 通常来说，计算机的io（与内存相关）操作和CPU计算（与CPU相关）是可以并行执行的，但是同步的编程模型会让后续任务等待，造成资源不能被很好的利用。



### 异步io与非阻塞io

##### 非阻塞io(操作系统层面)
> 操作系统会立即返回调用结果，只是这个结果不是真正的io处理结果，返回后，原调用方就不会阻塞。

要得到真正的io处理结果，方式有以下几种：
- read，轮询, 通过重复调用检查io状态来完成完整数据的读取；
- select，它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断；select轮询具有一个较弱的限制，就是由于它采用一个1024长度的数组来存储状态， 所以它最多可以同时检查1024个文件描述符。
- poll, select的改进方案，采用链表的方式避免数组长度的限制，还能避免不必要的检查。？
- epoll 等到操作系统真正io处理完后，通过事件的方式通知调用方；

##### 异步io(node层面实现)
> 依赖事件循环实现。完成整个异步I/O环节的有事件循环、观察者和请求对象等。
    
 - 事件循环(node实现)
 每执行一次循环的过程称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。      

 - 观察者
 事件循环的每个tick分为不同的阶段，大致有timers、pending callback、idle prepare、poll、check、close callback 5个阶段，详细参见[官网](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)。每个阶段可以理解为有不同的观察者，例如网络io观察者、文件io观察者、定时器观察者等，事件的来源就是这些观察者维护的队列。那这些队列又是怎么来的？在nodejs的libuv或者操作系统底层完成某些任务后（例如文件io），便会向对应的观察者返回该任务对应的任务请求对象，这些观察者会根据这些对象的状态结果（通常有一个status字段），来生成对应的事件，如success or fail，从而在事件循环执行对应的回调函数（这里的回调就是我们自己写的业务逻辑了）。

 - 请求对象
 从JavaScript发起调用到内核执行完I/O操作的过程过程中，存在一种中间产物，它就是请求对象。这个请求对象包含了我们业务层所写的回调函数，这是异步io的关键，因为此时node就可以直接给我们返回某个待定值，主线程里我们所写的代码就可以继续执行下去了，不然就只能阻塞在这里，等事件循环系统给我们真实的结果，这一般是很耗时的。

 参见图，来源深入浅出node.js p59。
 ![GbP5pn.png](https://s1.ax1x.com/2020/04/11/GbP5pn.png)